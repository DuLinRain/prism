/*Automatically generate from inject-bundle.js */
export const fileBundle = new Map(
    [
        ["component.ts", "import { createObservableObject } from \"./observable\";\n\n/**\n * Adds reusable prism functionality on top of the base HTMLElement class\n */\nexport abstract class Component<T> extends HTMLElement {\n    // The private cached (un-proxied) component data\n    _data: Partial<T> = {};\n    // Proxied data\n    _dataProxy: Partial<T> = {};\n\n    // Like isConnected but false until connectedCallback is finished\n    _isRendered: boolean = false; \n\n    // Caches for element lookup\n    // TODO new Map could be lazy\n    _elemCache: Map<string, Element> = new Map();\n    _ifSwapElemCache: Map<string, Element> = new Map();\n\n    abstract layout: true | undefined; // Used by router to detect if SSR content is layout\n    abstract _tree: T | undefined; // The primary observable\n\n    // A callback for when triggered from a router where params are a set of URL params\n    abstract load?: (params?: Object) => Promise<any>;\n\n    // CSR component\n    abstract render(): Generator<HTMLElement | string>;\n\n    // Bindings \n    abstract bindEventListeners(): void;\n    abstract unbindEventListeners(): void;\n\n    // User defined lifecycle callbacks (which don't interfere with connectedCallback)\n    abstract connected(): void | undefined;\n    abstract disconnected(): void | undefined;\n\n    // Used to retrieve elements inside the components DOM using a set class name by the Prism compiler\n    // Also caches the element as to not call querySelector every time\n    // Using query selector will work across csr and ssr component dom\n    // TODO cache invalidation if element is not connected???\n    getElem(id: string) {\n        if (this._elemCache.has(id)) {\n            return this._elemCache.get(id);\n        } else {\n            const elem = this.querySelector(`.${id}`);\n            if (elem) this._elemCache.set(id, elem);\n            return elem;\n        }\n    }\n\n    // Used to manually update the cache\n    setElem(id: string, elem: HTMLElement) {\n        elem.classList.add(id);\n        this._elemCache.set(id, elem);\n    }\n    \n    // Returns reactivity state of the component. Deep changes will be reflected in the dom. Will only create observable once\n    get data(): Partial<T> {\n        if (!this._isRendered) {\n            return this._data;\n        }\n        if (!this._tree) {\n            // @ts-expect-error ._bindings does exist statically on derived class (abstract static)\n            this._tree = createObservableObject.call(this, this.constructor._bindings, this._data, this._dataProxy)\n        }\n        return this._tree;\n    }\n\n    // Deeply assign values \n    set data(value) {\n        if (this._isRendered) {\n            Object.assign(this.data, value)\n        } else {\n            this._data = value\n        }\n    }\n\n    connectedCallback() {\n        // If component has been sever side rendered\n        if (this.hasAttribute(\"data-ssr\")) {\n            this._data = {};\n            this.bindEventListeners?.();\n        } else {\n            // Uses super to avoiding conflicting with a possible append override on the component \n            super.append(...this.render())\n        }\n        this.connected?.();\n        this._isRendered = true;\n    }\n\n    disconnectedCallback() {\n        this.disconnected?.();\n        this.unbindEventListeners?.();\n        this._isRendered = false;\n    }\n}"], 
        ["helpers.ts", "import type { Component } from \"./component\";\n\n/**\n * Utility function for swapping elements, used under #if cssu (client side state updates)\n * TODO caching element before regenerating\n * @param predicate The evaluated \n * @param id \n * @param elementGenerator A function to generate the nodes. The element predicate value is aware of the value of the predicate. TODO could be sent value to not reevaluate\n */\nexport function conditionalSwap(this: Component<any>, predicate: boolean, id: string, elementGenerator: () => HTMLElement): void {\n    const oldElem: Element = this.getElem(id);\n    // Don't change the element if the value of the predicate hasn't changed\n    if (!!predicate === oldElem.hasAttribute(\"data-else\")) {\n        // this._ifSwapElemCache.get(id) will always return the prev discarded (if it was generated)\n        const newElem = this._ifSwapElemCache.get(id) ?? elementGenerator.call(this);\n        this.setElem(id, newElem); // Manually update cache\n        this._ifSwapElemCache.set(id, oldElem);\n        oldElem.replaceWith(newElem); // Replace the element\n    }\n}\n\n/**\n * Given a element, cut out old children and for each old one call its remove function to remove it from the DOM.\n * This is when called by observable arrays\n * @param parent\n * @param length The target length for the elem.children\n */\nexport function setLength(parent: HTMLElement | null, length: number) {\n    if (parent) Array.from(parent.children).splice(length).forEach(elem => elem.remove());\n}\n\nexport function isArrayHoley<T>(array: Array<T>): boolean {\n    for (let i = 0; i < array.length; i++) {\n        if (array[i] === undefined) return true;\n    }\n    return false;\n}\n\n/**\n * Luckily CharacterData and Component have a assignable data property\n */\nexport function tryAssignData(elem: CharacterData | Component<any> | null, value: any) {\n    if (elem) elem.data = value;\n}"], 
        ["observable.ts", "import type { Component } from \"./component\";\nimport { isArrayHoley } from \"./helpers\";\n\n// TODO:\n// interface IMapping {\n//     type?: string,\n// }\n\n/**\n * Will create either a observable array, observable object or a existing object based on the `type` of `chunk`\n * @param data Any existing data\n * @param indexes Any indexes data is under\n */\nfunction createObservable(this: Component<any>, chunk: any, data: any, ...indexes: Array<number>) {\n    if (chunk.get) return chunk.get.call(this, ...indexes);\n    else if (chunk.type === \"Array\") return createObservableArray.call(this, chunk, data, [], ...indexes);\n    else return createObservableObject.call(this, chunk, data, {}, ...indexes);\n}\n\n/**\n * Creates a proxy for data which fronts a mapping tree.\n *  - Calls get bindings if data is not cached\n *  - On set bindings calls set operations\n *  - On nested data recursively makes observables\n * @param mappings A set of mappings (generated by Prism)\n * @param data Any original data\n * @param indexes If the observable is under a index\n */\nexport function createObservableObject<T>(\n    this: Component<T>,\n    mappings: any,\n    data: Partial<T>,\n    proxyCache: any = {}, // TODO explain\n    ...indexes: Array<number>\n): T {\n    return new Proxy(data, {\n        get: (target, prop, receiver) => {\n            // Work around for JSON.stringify thing\n            if (prop === \"toJSON\") {\n                return JSON.stringify(\n                    Object.assign(target,\n                        Object.fromEntries(Object.keys(receiver).map(k => [k, receiver[k]]))))\n            }\n            // Get the respective (c)hunk on the mapping tree\n            const chunk = mappings[prop];\n            if (!chunk) return;\n            // If chunk has type then the property is an object\n            if (chunk?.type) {\n                return proxyCache[prop] ??\n                    (proxyCache[prop] =\n                        createObservable.call(\n                            this,\n                            chunk,\n                            target[prop] ?? (target[prop] = chunk.type === \"Array\" ? [] : {}),\n                            ...indexes)\n                    )\n            }\n            // Try get property from cache (target) else get the prop and set its value to the cache\n            return target[prop] ?? (target[prop] = chunk.get?.call?.(this, ...indexes)); \n        },\n        set: (target, prop, value, receiver) => {\n            // Get the respective (c)hunk on the mapping tree\n            const chunk = mappings[prop];\n            // If has type assign the new object which ...\n            if (chunk?.type) {\n                Object.assign(proxyCache[prop] ?? receiver[prop], value);\n                if (Array.isArray(value)) {\n                    chunk?.set?.call?.(this, value, ...indexes);\n                    proxyCache[prop].length = value.length;\n                }\n            } else {\n                // Try call set handlers\n                chunk.set?.call?.(this, value, ...indexes)\n            }\n            return Reflect.set(target, prop, value)\n        },\n        has(_, p) {\n            return p in mappings;\n        },\n        ownKeys() {\n            return Object.keys(mappings)\n        },\n        getOwnPropertyDescriptor() {\n            return {configurable: true, enumerable: true, writable: true}\n        }\n    }) as T;\n}\n\nfunction createObservableArray<T>(\n    this: Component<any>,\n    mappings: any,\n    array: Array<T>,\n    proxyCache: Array<any> = [], // Not always needed\n    ...indexes: Array<number>\n): Array<T> {\n    return new Proxy(array, {\n        get: (target, prop, receiver) => {\n            if (prop === \"toJSON\") return JSON.stringify(Object.assign(target ?? [], Array.from(receiver)));\n            if (prop === \"length\") {\n                // Check that array is not wholely\n                return (!isArrayHoley(target) && target.length) || (target.length = mappings.length.get?.call?.(this, ...indexes) ?? 0);\n            }\n            if (mappings[\"*\"]?.type && typeof prop !== \"symbol\" && !isNaN((prop as number))) {\n                return proxyCache[prop]\n                    ?? (proxyCache[prop] = createObservable.call(\n                        this,\n                        mappings[\"*\"],\n                        array[prop] ?? (array[prop] = mappings[\"*\"].type === \"Array\" ? [] : {}),\n                        ...indexes,\n                        prop\n                    ));\n            }\n            return target[prop] ?? (target[prop] = mappings[\"*\"].get.call(this, ...indexes, prop));\n        },\n        set: (target, prop, value, receiver) => {\n            let prevLength = target.length;\n            Reflect.set(target, prop, value);\n            if (prop === \"length\") {\n                if (value < prevLength) {\n                    mappings.length.set.call(this, ...indexes, value);\n                    mappings?.set?.call?.(this, target, ...indexes);\n                    if (mappings.type[\"*\"]) proxyCache.length = value;\n                }\n            } else {\n                mappings?.set?.call?.(this, target, ...indexes);\n                if ((prop as number) >= prevLength) {\n                    mappings.push.call(this, value, ...indexes);\n                } else {\n                    if (mappings[\"*\"].type) {\n                        // Assign to the cache on a per property basis. If proxyCache does not exist create it from the receiver\n                        Object.assign(proxyCache[prop] ?? receiver[prop], value);\n                        if (Array.isArray(value)) proxyCache[prop].length = value.length;\n                    } else {\n                        mappings[\"*\"].set.call(this, value, ...indexes, prop);\n                    }\n                }\n            }\n            return true;\n        }\n    });\n}"], 
        ["render.ts", "/**\n * Used for maintaining consistency of splitting text from SSR\n * TODO remove if context==\"client\"\n */\nexport function createComment(comment: string = \"\"): Comment {\n    return document.createComment(comment);\n}\n\n// TODO temp\nconst svgElements = [\"svg\", \"g\", \"line\", \"rect\", \"path\", \"ellipse\", \"circle\"];\n\n/** \n * JSX minified render function \n * O's is used as a falsy value if the element does not have any attribute or events\n*/\nexport function h(tagName: string, attribute: Object | 0 = 0, events: Object | 0 = 0, ...children: Array<HTMLElement>): HTMLElement | SVGElement {\n    const isSvgElem = svgElements.includes(tagName);\n    const elem = isSvgElem ? document.createElementNS(\"http://www.w3.org/2000/svg\", tagName) : document.createElement(tagName);\n    if (attribute) {\n        Object.entries(attribute).forEach(([k, v]) => {\n            // TODO temp, haven't figured the weird characteristics of IDL attributes and SVG\n            if (k in elem && !isSvgElem) {\n                elem[k] = v;\n            } else {\n                elem.setAttribute(k, v);\n            }\n        });\n    }\n    if (events) {\n        Object.entries(events).forEach(([e, h]) => {\n            elem.addEventListener(e, h);\n        });\n    }\n    elem.append(...children);\n    return elem;\n}"], 
        ["router.ts", "import type { Component } from \"./component\";\nimport { h } from \"./render\";\n\n/**\n * Router used under Prism. Singleton\n */\nexport class Router extends HTMLElement {\n    static router: HTMLElement;\n    // Routes are injected by prism compiler\n    static routes: Array<[RegExp, string, string]>;\n\n    static loadedComponent: string | null = null;\n    static loadedLayout: string | null = null;\n\n    connectedCallback() {\n        Router.router = this;\n    }\n\n    /* \n        Called when whole application is loaded in, if goTo creates a element that has not been registered then it cannot find its goto method \n    */\n    static init() {\n        window.onpopstate = () => {\n            Router.goTo(document.location.pathname);\n        }\n        const fc = Router.router.firstElementChild;\n        if (!fc) {\n            Router.goTo(window.location.pathname, false)\n        } else {\n            if ((fc as Component<any>)?.layout) {\n                Router.loadedLayout = (fc as Component<any>).tagName.toLowerCase();\n                Router.loadedComponent = ((fc as Component<any>).firstElementChild as Component<any>).tagName.toLowerCase();\n            } else {\n                Router.loadedComponent = (fc as Component<any>).tagName.toLowerCase();\n            }\n        }\n    }\n\n    /**\n     * Used to bind anchor tags to ignore default behavior and do client side routing\n     */\n    static bind(event: MouseEvent) {\n        Router.goTo((event.currentTarget as HTMLElement).getAttribute(\"href\"));\n        event.preventDefault();\n    }\n\n    /**\n     * Only reason its async is for awaiting page load\n     * TODO explain\n     * @param url \n     * @param pushState \n     */\n    static async goTo(url: string, pushState = true) {\n        let router = this.router;\n        if (pushState) history.pushState({}, \"\", url)\n        for (const [pattern, component, layout] of this.routes) {\n            const match = url.match(pattern);\n            if (match) {\n                if (this.loadedComponent === component) {\n                    if (layout) {\n                        await (router.firstElementChild.firstElementChild as Component<any>).load?.(match.groups);\n                    } else {\n                        await (router.firstElementChild as Component<any>).load?.(match.groups);\n                    }\n                } else {\n                    let container = router;\n                    if (layout) {   \n                        if (Router.loadedLayout === layout) {\n                            container = router.firstElementChild as Component<any>;\n                        } else {\n                            const newLayout = h(layout);\n                            router.firstElementChild ? router.firstElementChild.replaceWith(newLayout) : router.append(newLayout);\n                            container = newLayout;\n                        }\n                    }\n                    Router.loadedComponent = component;\n                    const newComponent = h(component) as Component<any>;\n                    await newComponent.load?.(match.groups);\n                    // Rendering the component is deferred until till adding to dom which is next line\n                    container.firstElementChild ? container.firstElementChild.replaceWith(newComponent) : container.append(newComponent);\n                }\n                return;\n            }\n        }\n        throw Error(`No match found for ${url}`);\n    }\n}\n\nwindow.customElements.define(\"router-component\", Router);"], 
        ["server.ts", "/**\n * Escapes HTML on the server. From: https://stackoverflow.com/a/6234804/10048799\n */\nfunction escape(unsafe: string | number | boolean | Date): string {\n    return unsafe\n        .toString()\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}"], 
        ["template.html", "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <slot for=\"meta\"></slot>\n</head>\n\n<body>\n    <slot for=\"content\"></slot>\n</body>\n\n</html>"]
    ]
)