import type { Component } from "./component";
import { isArrayHoley } from "./helpers";

// TODO:
// interface IMapping {
//     type?: string,
// }

/**
 * Will create either a observable array, observable object or a existing object based on the `type` of `chunk`
 * @param data Any existing data
 * @param indexes Any indexes data is under
 */
function createObservable(this: Component<any>, chunk: any, data: any, ...indexes: Array<number>) {
    if (chunk.get) return chunk.get.call(this, ...indexes);
    else if (chunk.type === "Array") return createObservableArray.call(this, chunk, data, [], ...indexes);
    else return createObservableObject.call(this, chunk, data, {}, ...indexes);
}

/**
 * Creates a proxy for data which fronts a mapping tree.
 *  - Calls get bindings if data is not cached
 *  - On set bindings calls set operations
 *  - On nested data recursively makes observables
 * @param mappings A set of mappings (generated by Prism)
 * @param data Any original data
 * @param indexes If the observable is under a index
 */
export function createObservableObject<T>(
    this: Component<T>,
    mappings: any,
    data: Partial<T>,
    proxyCache: any = {}, // TODO explain
    ...indexes: Array<number>
): T {
    return new Proxy(data, {
        get: (target, prop, receiver) => {
            // Work around for JSON.stringify thing
            if (prop === "toJSON") {
                return JSON.stringify(
                    Object.assign(target,
                        Object.fromEntries(Object.keys(receiver).map(k => [k, receiver[k]]))))
            }
            // Get the respective (c)hunk on the mapping tree
            const chunk = mappings[prop];
            if (!chunk) return;
            // If chunk has type then the property is an object
            if (chunk?.type) {
                return proxyCache[prop] ??
                    (proxyCache[prop] =
                        createObservable.call(
                            this,
                            chunk,
                            target[prop] ?? (target[prop] = chunk.type === "Array" ? [] : {}),
                            ...indexes)
                    )
            }
            // Try get property from cache (target) else get the prop and set its value to the cache
            return target[prop] ?? (target[prop] = chunk.get?.call?.(this, ...indexes)); 
        },
        set: (target, prop, value, receiver) => {
            // Get the respective (c)hunk on the mapping tree
            const chunk = mappings[prop];
            // If has type assign the new object which ...
            if (chunk.type) {
                Object.assign(proxyCache[prop] ?? receiver[prop], value);
                if (Array.isArray(value)) {
                    chunk?.set?.call?.(this, value, ...indexes);
                    proxyCache[prop].length = value.length;
                }
            } else {
                // Try call set handlers
                chunk.set?.call?.(this, value, ...indexes)
            }
            return Reflect.set(target, prop, value)
        },
        has(_, p) {
            return p in mappings;
        },
        ownKeys() {
            return Object.keys(mappings)
        },
        getOwnPropertyDescriptor() {
            return {configurable: true, enumerable: true, writable: true}
        }
    }) as T;
}

function createObservableArray<T>(
    this: Component<any>,
    mappings: any,
    array: Array<T>,
    proxyCache: Array<any> = [], // Not always needed
    ...indexes: Array<number>
): Array<T> {
    return new Proxy(array, {
        get: (target, prop, receiver) => {
            if (prop === "toJSON") return JSON.stringify(Object.assign(target ?? [], Array.from(receiver)));
            if (prop === "length") {
                // Check that array is not wholely
                return (!isArrayHoley(target) && target.length) || (target.length = mappings.length.get?.call?.(this, ...indexes) ?? 0);
            }
            if (mappings["*"]?.type && typeof prop !== "symbol" && !isNaN((prop as number))) {
                return proxyCache[prop]
                    ?? (proxyCache[prop] = createObservable.call(
                        this,
                        mappings["*"],
                        array[prop] ?? (array[prop] = mappings["*"].type === "Array" ? [] : {}),
                        ...indexes,
                        prop
                    ));
            }
            return target[prop] ?? (target[prop] = mappings["*"].get.call(this, ...indexes, prop));
        },
        set: (target, prop, value, receiver) => {
            let prevLength = target.length;
            Reflect.set(target, prop, value);
            if (prop === "length") {
                if (value < prevLength) {
                    mappings.length.set.call(this, ...indexes, value);
                    mappings?.set?.call?.(this, target, ...indexes);
                    if (mappings.type["*"]) proxyCache.length = value;
                }
            } else {
                mappings?.set?.call?.(this, target, ...indexes);
                if ((prop as number) >= prevLength) {
                    mappings.push.call(this, value, ...indexes);
                } else {
                    if (mappings["*"].type) {
                        // Assign to the cache on a per property basis. If proxyCache does not exist create it from the receiver
                        Object.assign(proxyCache[prop] ?? receiver[prop], value);
                        if (Array.isArray(value)) proxyCache[prop].length = value.length;
                    } else {
                        mappings["*"].set.call(this, value, ...indexes, prop);
                    }
                }
            }
            return true;
        }
    });
}